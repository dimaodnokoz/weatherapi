# Тестовий проект Weather API для Software Engineering School 5.0

>Я вивчаю **[Laravel](https://laravel.com/docs/12.x)**. Використовую phpStorm.
Враховуючи, що в Laravel є функционал міграцій, розсилок, планувальника завдань, то буду будувати тестовий проект на цьому фреймворку, використовуючи це середовище.
Всі налаштування на локальному компі в мене вже виконані, тому для базового налаштування проекту лишилося кілька кроків.

## Створення і базове налаштування проекту
1) Створюю новий проект з консолі
```
laravel new proj_name
```
2) В .env файлі розкоменчую і трохи апдейчу змінні DB_
3) В терміналі Laravel стартую sql сервер, логінюсь в mysql, створюю базу даних (все відповідно до змінних в .env)
```
mysql.server start
create db_name
```
4) Видаляю в розділі database створені по дефолту модель, міграцію, фабрику і сідер для User - це не буде потрібно
5) В .env ставлю SESSION_DRIVER=array, щоб 'відключити використання сесій'
6) Лишаю дефолтні міграції для кешу та джобів (зокрема, джоби будуть потрібні для роботи шедулера, який виконуватиме розсилку для підписок)
7) Додаю для шедулера в .env APP_TIMEZONE=Europe/Kyiv
8) Після видалення файлів чищу кеш Laravel командами в терміналі
```
php artisan config:clear
php artisan cache:clear 
php artisan route:clear 
php artisan view:clear 
composer dump-autoload
```
9) Додаю Eloquent моделі Weather і Subscription та міграції для них згідно документації проекту 
```
php artisan make:model ModelName -m
```
10) Налаштовую моделі і міграції
11) Виконую міграції
```
php artisan migrate
```
13) Налаштовую перегляд БД в phpStorm: розділ database, data source - mysql, хост - localhost, БД / login / pswd - згідно.env
14) Перевіряю, чи створені потрібні таблиці
15) Піднімаю локальний сервер
```
php artisan serve
```
16) Налаштовую відправку email на реальні адреси - в .env файлі прописую значення для змінних MAIL_ з мого хостинг акаунту на [ukraine](https://ukraine.com.ua/). Альтернативно можна використовувати [mailtrap](https://mailtrap.io/), який дає inbox для перевірки отримання і вигляду листа (налаштування в .env також додав). 

## Раути та їх обробники

>Варто відмітити, що для кожного ендпоінту запропонованих в доці варіантів відповідей від API недостатньо - вони не
покривають всі можливі варіанти (наприклад, є помилки Клієнта, а є Сервера). Але код роблю під доку.

### api/weather
Додаю раут в routes/web.php.

В цілому логіка обробки невелика, тому можна було б додати її тут же у колбеку для раута.
Але в ній потрібно буде робити виклик до зовнішнього API, для чого знадобиться ін'єкція залежності від HTTP-клієнта,
яку за замовчуванням Laravel не впроваджує в раутах (потрібно реєструвати сервіс в контейнері залежнсотей).
Тому додаю для цього раута контролер
```
php artisan make:controller WeatherAPIController --invokable
```
Один і той самий зовнішній API запит для отримання погоди знадобиться тут в контролері для раута, для перевірки міста 
під час підписки, під час виконання розсилок за підписками. Тому розміщую його в трейт app/traits/WeatherAPIRequestsTrait.php,
який буду використовувати в усіх цих місцях.

### api/subscribe 
Додаю раут в routes/web.php.

По тій же причині, що і для раута вище (потрібен буде зовнішній API виклик для валідації міста),
додаю для цього раута контролер
```
php artisan make:controller SubscriptionController --invokable
```
Згідно доки роблю логіку для обох варіантів: "application/json", "application/x-www-form-urlencoded".

Базову валідацію проводжу за допомогою Laravel-фасаду Validator, окремим запитом в БД перевіряю існування підписки з
даним email, запитом до Weather API перевіряю валідність міста. Помилки не розшифровую, повертаю згідно доки.

Оскільки згідно доки токен підписки не зберігається в БД, але повинен бути завжди відомий,
при цьому унікальний і підходящий для використання в URL, то буду формувати його так
```
base64_encode(subscriptionId_city)
```
Для відправки email додаю потрібний пакет
```
composer require illuminate/mail
```
Для формування листа створюю і налаштовую Mailable клас
```
php artisan make:mail ConfirmSubscriptionMail
```
Додаю blade шаблон листа підтвердження.
```
resources/views/emails/confirm.blade.php
```
Щоб протестувати роботу цього контролера, додаю форму для підписки. Фактично це і є html-сторінка для тесту, про яку 
говориться в extra завданні
```
resources/views/subscribe.blade.php
```
і відповідний раут
```
/subscribe
```
>При тестуванні отримую помилку 419. Вона виникає через проблеми з валідацією CSRF token, яку для POST запитів вимагає
Laravel. І вона відтворюється незважаючи на те, що в моєму blade шаблоні є директива для створення токену і токен
передається в запиті. Ресерч показав, чо причина в SESSION_DRIVER=array (я додав це вище для "відключення" сесій), адже
при такому драйвері нема сесії і токен не зберігається між запитами. Тому цей і наступні раути, які працюють з
веб-сторінками, потрібно виключити з верифікації. Це і зробив в app/bootstrap/app.php. 

### api/confirm/{token}
Додаю раут в routes/web.php.

Додаю для цього раута контролер
```
php artisan make:controller ConfirmationController --invokable
```
Контролер фактично декодить токен, дістає з нього id і city. Якщо хочаб одного з параметрів нема - повертає 400, 	
Invalid token. Якщо параметри є - перевіряє наявність підписки з такими параметрами в базі. Якщо такої нема - повертає 
404, Token not found. Якщо ж така підписка є, то ставить їй confirmed true (незалежно від того, чи є там true) і поветає
200, Subscription confirmed successfully.

### api/unsubscribe/{token}
Додаю раут в routes/web.php.

Додаю для цього раута контролер
```
php artisan make:controller UnsubscriptionController --invokable
```
Цей контролер робить фактчно ті самі перевірки, що й ConfirmationController, але, якщо підписка в базі знайдена, то 
видаляє її, повертаючи 200, Unsubscribed successfully. 

### api/subscription
Додаю раут в routes/web.php. А для нього view subscription.blade.php.

В листі для підтвердження підписки я відправляю посилання на API раут для підтвердженя (api/confirm/{token}),
як сказано в завданні. І ще посилання на html сторінку (api/subscription?token={token}), через яку також можна
підтвердити підписку. Виклик API раута для підтвердженя виконується при завантаженні сторінки і таким чином вона одразу
показує результат.

Якщо підписку підтвердити не вдалося, то сторінка покаже повідомлення і посилання на сторінку api/subscribe для підписки.

Якщо ж підписка підтверджена успішно, то поряд з повідомленням буде посилання
api/subscription?token={token}&unsubscribe=y для відписки (токен ми вже знаємо). Воно викликає API відписки
api/unsubscribe/{token} і далі сторінка покаже повідомлення про результат.

Власне, це вже друга html сторінка для тестів.

## Scheduler і розсилка
Додаю одну джобу для виконання розсилок
```
php artisan make:job EmailingJob
```
В routes/console.php додаю щогодинну обробку джоби шедулером, не вказую чергу і конекшн - будуть дефолтні
```
Schedule::job(new EmailingJob)->hourly();
```
В джобі дістаю з Carbon поточну годину. Якщо вона 10 (хардкоджу як для тестового проекту), то потрібно ініціювати
розсилку для всіх confirmed=true підписок з будь-якою frequency - для щогодинних само собою, для щоденних - хай це буде 
обраний час, коли її робимо. Якщо година відмінна від 10, то потрібно ініціювати розсилку для всіх confirmed=true
підписок з frequency=hourly.

Для тестового завдання реалізую спрощену логіку, припускаючи, що кількість підписок невелика і всі листи встигаємо розіслати
за час, виділений для джоби. Спершу дістаю з бази унікальний перелік міст для confirmed=true підписок, що відповідають умовам
з першого абзацу. Ітеруюся по переліку міст, для кожного дістаю погоду і в разі успіху дістаю мейли всіх confirmed=true
підписок, що відповідають умовам з першого абзацу + мають поточний city. Шлю по мейду з погодою на кожний
(тут можна реалізувати відправку одного чи кількох мейлів з bcc).

Для формування листа створюю і налаштовую Mailable клас
```
php artisan make:mail WeatherMail
```
Додаю blade шаблон листа підтвердження.
```
resources/views/emails/weather.blade.php
```
Для великої кількості підписок потрібно використовувати job batching, створюючи в батчі підджоби для невеликих чанків,
які формуються шляхом ітерації по lazy колекції. Це дозволить вирішити проблему таймауту основної джоби, яка діспатчить
батч, бо так її задача заключатиметься лиш в створенні батчу і виконуватиметься достатньо швидко. В логіці підджоб треба
виключити дублікати розсилки на випадок автоматичного перезапуску джоби в рамках спроб.

>Важливо: на проді для обробки джоби потрібно запустити cron з похвилинним виконанням, який запускає worker, якщо той не запущено.
Орієнтовна команда:
```
pgrep -f "queue:work" > /dev/null || php /path-to-project/artisan queue:work
```

>Важливо: на проді для scheduler потрібно запустити cron з похвилинним виконанням, який запускає scheduler.
Орієнтовна команда:
```
* * * * * cd /path-to-project && php artisan schedule:run >> /dev/null 2>&1
```
На локалці протестовано за допомогою php artisan queue:work, php artisan schedule:work і з everyMinute для scheduler.

## Docker і deploy
